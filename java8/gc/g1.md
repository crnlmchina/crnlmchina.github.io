## Garbage-First Garbage Collector

> G1垃圾收集器是一个服务器端的垃圾回收器，设计用于多核系统和大内存的应用。它试图在高吞吐的场景下达到用户期望的GC停顿时间。全堆内存的操作，比如全局标记，同应用线程并发进行，这避免GC停顿时间随堆内存和应用数据的增大而线性增长。

> G1使用多种手段来实现高性能和低停顿。

> 堆被分解为多个大小相等的区块，每块对应一段连续的逻辑内存。
> G1在整个堆内并发得对对象的存活状态进行全局标记。
> 全局标记阶段完成后，G1确定了那些最空的区块。
> 它优先回收那些区块，因为它们能释放大量的内存。
> 这也是这款收集器的名称来由：`Garbage-First`。
> 基于此，那些全是可回收对象的区块的收集和压缩行为被简化了。
> G1使用一个被称为“停顿预测模型”的东西来根据用户期望的停顿时间来决定每次回收的区块数目。

> 在压缩和释放内存阶段，G1会把对象从一个或多个区块中复制到另一个区块中。
> 在多核系统中，这个阶段会并行得进行以缩短GC停顿时间。
> G1增量式得进行这个压缩行为以减少碎片，这是其它收集器所不具备的特性。CMS不会进行压缩重排，而并行收集器只进行全局的压缩重排，从而会引发较长的停顿。

> 需要重点关注的是G1并不是实时的收集器。它只是尽可能得去达到用户期望的GC停顿，而不是绝对。
> 根据前面的收集记录，G1会根据用户期望的GC停顿时间来估算需要回收多少块区块，这就是G1的“停顿预测模型”。

> G1专注于在大堆内存下需要受限的GC延迟的场景。比如大于6G的堆和小于0.5s的停顿。

> 当前使用CMS和ParallelGC的应用，如果满足以下特点，将会在切换到G1后受益：

- 应用使用了超过50%的堆内存
- 对象的分配率或迁移率波动明显
- 应用出现长时间停顿(超过0.5s或1s)

> G1设计用于替代CMS。G1拥有压缩重排和停顿预测模型等优势。

> ![Description of "Figure 9-1 Heap Division by G1"](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_004_grbg_frst_hp.png)

> G1只有逻辑上的分代。一些空的区块用来表示逻辑上的年轻代。图中浅蓝色的区块为年轻代，深蓝色的区块代表年老代。
> 对象在逻辑年轻代分配，当年轻代满了后，那些区块将被回收(Young GC)。
> 某些情况下，逻辑年老代中的对象也会被同时回收。
> 这被称为混合收集(mixed collection)。
> 图中标识了一次混合收集，正在被收集的区块被标为红色。
> 收集器会将存活对象压缩到指定的空的区块中去，根据对象的年龄，可能被复制到Survior区块或直接复制到年老代的区块。图中标为“H”的区块是一些超过区块一半大小的大对象，它们会被特殊处理。

### Allocation (Evacuation) Failure
> 和CMS一样，G1在应用线程运行的同时进行部分收集工作，那么就有可能出现应用分配对象的速度超过收集器回收对象的速度。在G1中，这种情况发生在压缩重排阶段，当可用的空的区块无法找到时，这时Full GC会被触发。

### Floating Garbage
> 在收集过程中生命周期结束的对象可能未被回收。G1使用SATB(snapshot-at-the-beginning)技术来确认找到所有存活的对象，SATB在全局并发标记阶段标记那些存活对象，这类似于CMS的incremental update。

### Pauses
> G1会暂停应用复制存活对象到新的区块中，这些停顿可能出现在young collection或mixed collection中。