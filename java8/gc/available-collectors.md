## 可用的收集器
> Java HotSpot VM提供了三种类型的收集器，分别有不同的性能特性。

- 串行收集器(The serial collector)使用一个单独的线程进行垃圾回收，相对比较效率，因为它避免了线程间协作的开销。串行收集器比较适合使用在单核的机器上，因为它无法利用多核。另外，它还适用于多核机器上的小型数据应用(约100M)。串行收集器在特定平台上是默认收集器，也可以显式指定: `-XX:+UseSerialGC`。

- 并行收集器(The parallel collector)并行得进行Minor GC，显著降低了GC的开销。并行收集器为多核机器上的中型数据和大型数据应用设计。并行收集在特定平台上是默认收集器，也可以显式指定：`-XX:+UseParallelGC`。
并行压缩特性使得并行收集器可以并行得进行Major GC，如果关闭并行压缩，那么Major GC只能单线程执行。并行压缩特性在使用参数`-XX:+UseParallelGC`时默认开启，如果需要关闭它，使用参数`-XX:-UseParallelOldGC`。

- 并发收集器(The mostly concurrent collector)的大部分工作都是并发进行的，比如在应用运行的同时，目标是缩短GC的暂停时间。它被设计用于那些对于响应时间有严格要求的中型数据和大型数据应用，一般情况下这些应用关心应用停顿时间甚于吞吐量。HotSpot虚拟机提供了两种实现供用户选择：CMS Collector(`-XX:+UseConcMarkSweepGC`)和G1 Collector(`-XX:+UseG1GC`)。

### 选择收集器
> 优先让JVM自主选择收集器，如果应用没有严格的停顿时间要求。如有必要，调整堆大小来改善性能。如果性能还是达不到目标，可以参考以下建议作为GC优化的起点。

- 如果应用数据量比较小(不到100M)，使用串行收集器(`-XX:+UseSerialGC`)。

- 如果应用运行在单核机器上并且没有GC停顿时间要求，让JVM自主选择收集器，或使用串行收集器(`-XX:+UseSerialGC`)。

- 如果应用的吞吐性能是优先考虑的，并且没有GC停顿时间要求或可以接受约1秒的停顿时间，使用并行收集器(`-XX:+UseParallelGC`)。

- 如果应用的响应时间比吞吐性能更重要，并且要求GC停顿时间少于1秒，使用并发收集器(`-XX:+UseConcMarkSweepGC`或`-XX:+UseG1GC`)

> 以上建议只是GC调优的起点，因为性能还受很多其它因素的影响，比如堆的大小/应用的活动数据大小/处理器的数据以及速度，停顿时间对这些因素都比较敏感，所以上面提到的1秒的参考值只是估值。
> 并行收集器在特定的场景下会超出1秒的停顿时间，同样并发收集也不能保证停顿时间一定会低于1秒。

> 若推荐的收集器没有达到期望的性能，首先调优堆的及分代的大小，其次再去更换收集器。

> 使用并发收集器控制GC停顿时间，使用并行收集器在多核机器上提高吞吐量。